<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ImmersAV: ImmersAV</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ImmersAV
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A toolkit for immersive audiovisual composition.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ImmersAV </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>by Bryan Dunphy</p>
<p>ImmersAV is an open source toolkit for immersive audiovisual composition. It was built around a focused approach to composition based on generative audio, raymarching and interactive machine learning techniques.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Aims:</h1>
<ul>
<li>Provide well defined, independent areas for generating audio and visual material.</li>
<li>Provide a class that can be used to generate, send and receive data from:<ul>
<li>machine learning algorithms</li>
<li>VR hardware sensors</li>
<li>audio and visual processing engines</li>
</ul>
</li>
<li>Allow for direct rendering on a VR headset.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Dependencies:</h1>
<ul>
<li>OpenVR</li>
<li>Csound6</li>
<li>OpenGL4</li>
<li>glm</li>
<li>glfw3</li>
<li>Glew</li>
<li>CMake3</li>
<li>RapidLib</li>
<li>libsndfile</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Windows:</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Setup:</h2>
<ol type="1">
<li>Download (64 bit):<ul>
<li>CMake: <a href="https://cmake.org/download/">https://cmake.org/download/</a></li>
<li>OpenVR: <a href="https://github.com/ValveSoftware/openvr">https://github.com/ValveSoftware/openvr</a></li>
<li>Csound 6: <a href="https://csound.com/download.html">https://csound.com/download.html</a></li>
<li>glm: <a href="https://github.com/g-truc/glm/tags">https://github.com/g-truc/glm/tags</a></li>
<li>glfw3: <a href="https://www.glfw.org/download.html">https://www.glfw.org/download.html</a></li>
<li>glew: <a href="http://glew.sourceforge.net/">http://glew.sourceforge.net/</a></li>
<li>libsndfile: <a href="http://www.mega-nerd.com/libsndfile/#Download">http://www.mega-nerd.com/libsndfile/#Download</a></li>
</ul>
</li>
<li>Install CMake and Csound according to their instructions.</li>
<li>Create directories:<ul>
<li>ImmersAV/bin/</li>
<li>ImmersAV/lib/</li>
<li>ImmersAV/include/</li>
</ul>
</li>
<li>Move the following files to bin/:<ul>
<li>csound64.dll</li>
<li>glew32.dll</li>
<li>openvr_api.dll</li>
<li>libsndfile-1.dll</li>
</ul>
</li>
<li>Move the following files to lib/:<ul>
<li>csound64.lib</li>
<li>openvr_api.lib</li>
<li>glew32.lib</li>
<li>glfw3.lib</li>
<li>libsndfile-1.lib</li>
</ul>
</li>
<li>Move header files from OpenVR to include/.</li>
</ol>
<h2><a class="anchor" id="autotoc_md5"></a>
Build and run using the Visual Studio command line:</h2>
<ol type="1">
<li>Run the newCmakeBuild.bat script.</li>
<li>Use the following commands to build the project:<ul>
<li>cd build/</li>
<li>nmake</li>
</ul>
</li>
<li>Move the following files to ImmersAV/build/src/:<ul>
<li>From ImmersAV/bin/:<ul>
<li>csound64.dll</li>
<li>openvr_api.dll</li>
<li>glew32.dll</li>
<li>libsndfile-1.dll</li>
</ul>
</li>
<li>From ImmersAV/examples/:<ul>
<li>*_example.csd</li>
<li>*_example.vert</li>
<li>*_example.frag</li>
</ul>
</li>
<li>From ImmersAV/data/:<ul>
<li>hrtf-48000-left.dat</li>
<li>hrtf-48000-right.dat</li>
<li>avr_iml_actions.json</li>
<li>avr_iml_default_bindings.json</li>
</ul>
</li>
</ul>
</li>
<li>Navigate (cd) to ImmersAV/build/src/.</li>
<li>Type the following command to run the application with one of the examples:<ul>
<li>With VR rendering:<ul>
<li>avr audioReactive_example</li>
</ul>
</li>
<li>Without VR rendering (for development):<ul>
<li>avr audioReactive_example -dev</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md6"></a>
MacOS:</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Setup:</h2>
<ol type="1">
<li>Download (64 bit):<ul>
<li>CMake <a href="https://cmake.org/download/">https://cmake.org/download/</a></li>
<li>OpenVR: <a href="https://github.com/ValveSoftware/openvr">https://github.com/ValveSoftware/openvr</a></li>
<li>Csound 6: <a href="https://csound.com/download.html">https://csound.com/download.html</a></li>
<li>glm: <a href="https://github.com/g-truc/glm/tags">https://github.com/g-truc/glm/tags</a></li>
<li>glfw3: <a href="https://www.glfw.org/download.html">https://www.glfw.org/download.html</a></li>
<li>RAPID-MIX: <a href="https://www.doc.gold.ac.uk/eavi/rapidmixapi.com/index.php/getting-started/download-and-setup/">https://www.doc.gold.ac.uk/eavi/rapidmixapi.com/index.php/getting-started/download-and-setup/</a></li>
</ul>
</li>
<li>Install CMake and Csound according to their instructions.</li>
<li>Move the following to /Library/Frameworks/:<ul>
<li>CsoundLib64.framework</li>
<li>OpenVR.framework</li>
</ul>
</li>
<li>Move the following to /usr/local/lib/:<ul>
<li>libcsnd.6.0.dylib</li>
<li>libcsnd6.6.0.dylib</li>
<li>libopenvr_api.dylib</li>
<li>libRAPID-MIX_API.dylib</li>
</ul>
</li>
<li>Create ImmersAV/include/ directory.</li>
<li>Move the following to ImmersAV/include/:<ul>
<li>From openvr/:<ul>
<li>headers/*</li>
</ul>
</li>
<li>From RAPID-MIX_API/src:<ul>
<li>rapidmix.h</li>
<li>machineLearning/*</li>
<li>signalProcessing/*</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md8"></a>
Build and Run using the terminal:</h2>
<ol type="1">
<li>Type the following commands into the terminal:<ul>
<li>mkdir build/</li>
<li>cd build</li>
<li>cmake ..</li>
</ul>
</li>
<li>When CMake has prepared the build files type 'make'.</li>
<li>Move the following files:<ul>
<li>From ImmersAV/examples/:<ul>
<li>*_example.csd</li>
<li>*_example.vert</li>
<li>*_example.frag</li>
</ul>
</li>
<li>From ImmersAV/data/:<ul>
<li>hrtf-48000-left.dat</li>
<li>hrtf-48000-right.dat</li>
</ul>
</li>
</ul>
</li>
<li>Navigate (cd) to ImmersAV/build/src/.</li>
<li>To run an example project type the following into the terminal:<ul>
<li>With VR rendering:<ul>
<li>./avr audioReactive_example</li>
</ul>
</li>
<li>Without VR (for development):<ul>
<li>./avr audioReactive_example -dev</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md9"></a>
Workflow Overview</h1>
<p>The ImmersAV toolkit is intended to provide three main contexts for creating and mapping material. </p><pre class="fragment">- Csound `csd` file.
- GLSL fragment shader.
- `Studio()` class.
</pre><p>All the audio is generated in the <code>csd</code> file. All the visuals (with the exception of default virtual controllers) are generated in the fragment shader. The <code>Studio()</code> conceptually sits between the audio and visual areas. Any data passes through here and is mapped to the audio and visuals. Data can also be generated here.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Controller Sensor Data</h1>
<p>When in VR, the controller position and orientation can be accessed through <code>Studio::Update()</code>. The vectors <code>glm::vec3 controllerWorldPos_0</code> and <code>glm::vec3 controllerWorldPos_1</code> contain the <code>x</code>, <code>y</code> and <code>z</code> cartesian coordinates of the controller. The quaternions <code>glm::quat controllerQuat_0</code> and <code>glm::quat controllerQuat_1</code> contain the orientations of the controllers.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Audio Engine</h1>
<h2><a class="anchor" id="autotoc_md12"></a>
Audio Thread and CSD Setup</h2>
<p>The Csound API is used to communicate between the main application and the Csound instance. For an introduction to the Csound API see <a href="http://floss.booktype.pro/csound/a-the-csound-api/">http://floss.booktype.pro/csound/a-the-csound-api/</a>. Here, the Csound API is wrapped in the <code>StudioTools()</code> class, which contains functions that create the Csound instance and set up the sound sources used in the scene. <br  />
</p>
<div class="fragment"><div class="line">m_pStTools = new StudioTools();</div>
<div class="line"> </div>
<div class="line">//audio setup</div>
<div class="line">CsoundSession* csSession = m_pStTools-&gt;PCsoundSetup(csd);</div>
<div class="line">    </div>
<div class="line">if(!m_pStTools-&gt;BSoundSourceSetup(csSession, NUM_SOUND_SOURCES))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; &quot;Studio::setup sound sources not set up&quot; &lt;&lt; std::endl;</div>
<div class="line">    return false;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The pointer <code>m_pStTools</code> is used to access functions from the <code>StudioTools()</code> class. The function <code>PCsoundSetup()</code> initialises the Csound instance and creates a new thread for it to run on. This function returns a pointer to Csound, <code>csSession</code>.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Virtual Sound Source Placement</h2>
<p>The function <code>BSoundSourcesSetup()</code> passes the <code>csSession</code> pointer and the number of required sound sources to be placed in the virtual scene. These sound sources can then be placed and moved around in the <code>Studio::Update()</code> function.</p>
<div class="fragment"><div class="line">// example sound source at origin</div>
<div class="line">StudioTools::SoundSourceData soundSource1;</div>
<div class="line">glm::vec4 sourcePosWorldSpace = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f);</div>
<div class="line">soundSource1.position = sourcePosWorldSpace;</div>
<div class="line">std::vector&lt;StudioTools::SoundSourceData&gt; soundSources;</div>
<div class="line">soundSources.push_back(soundSource1);</div>
<div class="line"> </div>
<div class="line">m_pStTools-&gt;SoundSourceUpdate(soundSources, viewMat);</div>
</div><!-- fragment --><p>The struct <code>StudioTools::SoundSourceData</code> contains all the data needed to place the sound source in the space. The world space coordinates of the sound source are assigned to <code>soundSource1.position</code>. Here it is simply placed at the origin. The sound source is then added to a vector, <code>soundSources</code>, that contains all the sound sources. Here there is only one. The sound source can be moved and rotated through the space by updating <code>soundSource1.position</code>. The function <code>SoundSourceUpdate()</code> sends the position, elevation and azimuth values to the <code>csd</code> file.</p>
<div class="fragment"><div class="line">;**************************************************************************************</div>
<div class="line">instr 2 ; HRTF Instrument</div>
<div class="line">;**************************************************************************************</div>
<div class="line">kPortTime linseg 0.0, 0.001, 0.05 </div>
<div class="line"> </div>
<div class="line">iNumAudioSources init 1</div>
<div class="line"> </div>
<div class="line">kAzimuths[]     init    iNumAudioSources</div>
<div class="line">kElevations[]   init    iNumAudioSources</div>
<div class="line">kDistances[]    init    iNumAudioSources</div>
<div class="line"> </div>
<div class="line">kCount = 0</div>
<div class="line"> </div>
<div class="line">channelLoop:</div>
<div class="line"> </div>
<div class="line">    S_azimuth sprintfk &quot;azimuth%d&quot;, kCount</div>
<div class="line">    kAzimuths[kCount]   chnget S_azimuth</div>
<div class="line"> </div>
<div class="line">    S_elevation sprintfk &quot;elevation%d&quot;, kCount </div>
<div class="line">    kElevations[kCount]     chnget S_elevation </div>
<div class="line"> </div>
<div class="line">    S_distance sprintfk &quot;distance%d&quot;, kCount</div>
<div class="line">    kDistances[kCount]  chnget S_distance </div>
<div class="line"> </div>
<div class="line">    loop_lt kCount, 1, iNumAudioSources, channelLoop</div>
<div class="line">    </div>
<div class="line">aInstSigs[] init    iNumAudioSources</div>
<div class="line">aInstSigs[0] = gaOut</div>
<div class="line"> </div>
<div class="line">aLeftSigs[] init    iNumAudioSources</div>
<div class="line">aRightSigs[]    init    iNumAudioSources</div>
<div class="line">kDistVals[] init    iNumAudioSources</div>
<div class="line"> </div>
<div class="line">kDistVals[0] portk kDistances[0], kPortTime ;to filter out audio artifacts due to the distance changing too quickly</div>
<div class="line">    </div>
<div class="line">aLeftSigs[0], aRightSigs[0]  hrtfmove2  aInstSigs[0], kAzimuths[0], kElevations[0], &quot;hrtf-48000-left.dat&quot;, &quot;hrtf-48000-right.dat&quot;, 4, 9.0, 48000</div>
<div class="line">aLeftSigs[0] = aLeftSigs[0] / (kDistVals[0] + 0.00001)</div>
<div class="line">aRightSigs[0] = aRightSigs[0] / (kDistVals[0] + 0.00001)</div>
<div class="line"> </div>
<div class="line">aL init 0</div>
<div class="line">aR init 0</div>
<div class="line"> </div>
<div class="line">aL = aLeftSigs[0]</div>
<div class="line">aR = aRightSigs[0]</div>
<div class="line"> </div>
<div class="line">outs    aL, aR</div>
<div class="line">endin</div>
</div><!-- fragment --><p>The <code>HRTF Instrument</code> receives position, elevation and azimuth data from <code>Studio::Update()</code> every frame. The number of audio sources is initialised at the start of the instrument and assigned to the variable <code>iNumAudioSources</code>. This number is used to determine the size of the arrays <code>kAzimuths[]</code>, <code>kElevations[]</code> and <code>kDistances[]</code>. These arrays are then populated in <code>channelLoop</code> using <code>chnget</code> to retrieve the data from named channels. The audio signals are then stored in the array <code>aInstSigs[]</code>. Here there is just one signal <code>gaOut</code>. Arrays for the left and right audio channels and distance values are then initialised. The distance values need to be smoothed out using <code>portk</code> as rapidly changing values will introduce discontinuities into the audio signal. The opcode <code>hrtfmove2</code> is used to apply HRTF filters to the audio source. It receives the audio signal, azimuth and elevation values as input and uses the data files <code>"hrtf-48000-left.dat"</code> and <code>"hrtf-48000-right.dat"</code> to generate dynamic 3D binaural audio signals. The sample rate is specified as 48kHz so the overall Csound sample rate, <code>sr</code>, has to match this. The left and right signals are then divided by the distance values contained in <code>kDistVals[]</code>. The stereo signal is then output to the main output channel. This instrument needs to run continuously. This is achieved in the score section like so:</p>
<div class="fragment"><div class="line">&lt;CsScore&gt;</div>
<div class="line"> </div>
<div class="line">f0  86400 ;keep csound running for a day</div>
<div class="line"> </div>
<div class="line">i1 1 -1 </div>
<div class="line"> </div>
<div class="line">i2 1 -1</div>
<div class="line"> </div>
<div class="line">e</div>
<div class="line">&lt;/CsScore&gt;</div>
</div><!-- fragment --><p>Here an <code>f0</code> statement is used to keep Csound running. Then the <code>i</code> statements specify a note length of -1 which means the instrument is always on.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Sends and Returns</h2>
<p>Data can be sent to and returned from Csound using the functions <code>StudioTools::BCsoundSend()</code> and <code>StudioTools::BCsoundReturn()</code>.</p>
<div class="fragment"><div class="line">//setup sends to csound</div>
<div class="line">std::vector&lt;const char*&gt; sendNames;</div>
<div class="line"> </div>
<div class="line">sendNames.push_back(&quot;sineControlVal&quot;);</div>
<div class="line">m_vSendVals.push_back(m_cspSineControlVal); </div>
<div class="line"> </div>
<div class="line">sendNames.push_back(&quot;randomVal&quot;);</div>
<div class="line">m_vSendVals.push_back(m_cspRandVal);</div>
<div class="line"> </div>
<div class="line">m_pStTools-&gt;BCsoundSend(csSession, sendNames, m_vSendVals);</div>
<div class="line"> </div>
<div class="line">//setup returns from csound </div>
<div class="line">std::vector&lt;const char*&gt; returnNames;</div>
<div class="line"> </div>
<div class="line">returnNames.push_back(&quot;pitchOut&quot;);</div>
<div class="line">m_vReturnVals.push_back(m_pPitchOut);</div>
<div class="line"> </div>
<div class="line">returnNames.push_back(&quot;freqOut&quot;);</div>
<div class="line">m_vReturnVals.push_back(m_pFreqOut);</div>
<div class="line"> </div>
<div class="line">m_pStTools-&gt;BCsoundReturn(csSession, returnNames, m_vReturnVals);   </div>
</div><!-- fragment --><p>A vector of type <code>const char*</code> is used to store the channel names. For send channels this vector is <code>sendNames</code> and for return channels the vector is called <code>returnNames</code>. These names must match the string arguments given to <code>chnget</code> and <code>chnset</code> in the <code>csd</code> file. The data values are stored in seperate member vectors named <code>m_vSendVals</code> and <code>m_vReturnVals</code> respectively. These are declared in <em>Studio.hpp</em>. Csound pointers of type <code>MYFLT*</code> are sent to Csound. The values can be assigned to specific elements in the send vector within <code>Studio::Update()</code>.</p>
<div class="fragment"><div class="line">//example control signal - sine function</div>
<div class="line">//sent to shader and csound</div>
<div class="line">m_fSineControlVal = sin(glfwGetTime() * 0.33f);</div>
<div class="line">*m_vSendVals[0] = (MYFLT)m_fSineControlVal;</div>
</div><!-- fragment --><p>For example, the <code>float m_fSineControlVal</code> is cast to <code>MYFLT</code> and assigned to element 0 of <code>m_vSendVals</code>. This aligns with the setup code above in that the Csound pointer <code>m_cspSineControlVal</code> is the first value to be added to the vector. It follows then that the value intended for <code>m_cspRandVal</code> is referenced using <code>*m_vSendVals[1]</code>. The return values are accessed by referencing the specific element of the <code>m_vReturnVals</code> vector.</p>
<div class="fragment"><div class="line">if(*m_vReturnVals[0] &gt; 0) m_fTargetVal = *m_vReturnVals[0]; </div>
</div><!-- fragment --><p>For example, element 0 is dereferenced here and assigned to the <code>float m_fTargetVal</code>. Once the channel names and data vectors are set up above, they are passed along with the <code>csSession</code> pointer to <code>StudioTools::BCsoundSend()</code> and <code>StudioTools::BCsoundReturn()</code>.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Graphics Renderer</h1>
<p>The graphics are rendered using OpenGL and GLSL shaders. The shaders are set up specifically to allow for raymarching combined with raster graphics. This is to account for the rendering of virtual controllers within VR and to ensure they interact as expected with the raymarched graphics.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Shader Setup</h2>
<p>Just as all the audio is generated in the <code>csd</code> file, the shaders are set up to encourage the generation of all the visual material in the fragment shader. In <code>Studio::Setup()</code> the OpenGL code necessary to set up a raymarching quad is called using:</p>
<div class="fragment"><div class="line">//setup quad to use for raymarching</div>
<div class="line">m_pStTools-&gt;RaymarchQuadSetup(shaderProg);</div>
</div><!-- fragment --><p>This sets up the quad vertices to be accessed in the vertex shader. The standard set up of the vertex shader is as follows:</p>
<div class="fragment"><div class="line">#version 410 </div>
<div class="line"> </div>
<div class="line">layout(location = 0) in vec3 position;</div>
<div class="line"> </div>
<div class="line">uniform mat4 InvMVEP;</div>
<div class="line"> </div>
<div class="line">out vec4 nearPos;</div>
<div class="line">out vec4 farPos;</div>
<div class="line"> </div>
<div class="line">void main() </div>
<div class="line">{</div>
<div class="line">    //********* code from https://encreative.blogspot.com/2019/05/computing-ray-origin-and-direction-from.html *******//</div>
<div class="line"> </div>
<div class="line">    gl_Position = vec4(position, 1.0);</div>
<div class="line"> </div>
<div class="line">    //get 2D projection of this vertex in normalised device coordinates</div>
<div class="line">    vec2 ndcPos = gl_Position.xy / gl_Position.w;</div>
<div class="line">    </div>
<div class="line">    //compute rays start and end points in the unit cube defined by ndc&#39;s</div>
<div class="line">    nearPos = InvMVEP * vec4(ndcPos, -1.0, 1.0);</div>
<div class="line">    farPos = InvMVEP * vec4(ndcPos, 1.0, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here the vertex position is converted to normalised device coordinates in order to use the unit cube to calculate the beginning and end positions of the ray. These are then projected back into world space using the inverse model view eye projection matrix. The use of the term 'eye' here is due to the extra matrix used in OpenVR to calculate the offset angle between the eyes in the head mounted display (HMD). The near and far positions of the ray are then output to the fragment shader where the direction of the ray can be calculated. The vertex shader as it appears here does not need to be modified and can be re-used from project to project because the majority of the visual material is generated in the fragment shader. The default components of the fragment shader are as follows:</p>
<div class="fragment"><div class="line">#version 410  </div>
<div class="line">uniform mat4 MVEPMat;</div>
<div class="line"> </div>
<div class="line">in vec4 nearPos;</div>
<div class="line">in vec4 farPos;</div>
<div class="line"> </div>
<div class="line">layout(location = 0) out vec4 fragColour; </div>
<div class="line">layout(location = 1) out vec4 dataOut;</div>
<div class="line"> </div>
<div class="line">void main()</div>
<div class="line">{</div>
<div class="line">    //************* ray setup code from </div>
<div class="line">    //https://encreative.blogspot.com/2019/05/computing-ray-origin-and-direction-from.html*/</div>
<div class="line">    </div>
<div class="line">    //set up the ray</div>
<div class="line">    vec3 rayOrigin = nearPos.xyz / nearPos.w;</div>
<div class="line">    vec3 rayEnd = farPos.xyz / farPos.w;</div>
<div class="line">    vec3 rayDir = rayEnd - rayOrigin;</div>
<div class="line">    rayDir = normalize(rayDir); </div>
<div class="line">    </div>
<div class="line">    // raymarch the point</div>
<div class="line">    float dist = march(rayOrigin, rayDir);</div>
<div class="line">    vec3 pos = rayOrigin + dist * rayDir;</div>
<div class="line"> </div>
<div class="line">    // calculate colour and lighting here</div>
<div class="line">    vec3 colour;</div>
<div class="line"> </div>
<div class="line">    // gamma correction</div>
<div class="line">    colour = pow(colour, vec3(1.0/2.2));</div>
<div class="line">    </div>
<div class="line">    // Output to screen</div>
<div class="line">    fragColour = vec4(colour,1.0);</div>
<div class="line"> </div>
<div class="line">    // Output to PBO</div>
<div class="line">    dataOut = fragColour;</div>
<div class="line"> </div>
<div class="line">//-----------------------------------------------------------------------------</div>
<div class="line">// To calculate depth for use with rasterized material e.g. VR controllers</div>
<div class="line">//-----------------------------------------------------------------------------</div>
<div class="line">// code adapted from Michael Hvidtfeldt Christensen and James Susinno&#39;s blogs</div>
<div class="line">// http://jimbo00000.github.io/opengl/portable/programming/vr/perspective/matrixmath/2016/02/15/raymarching-and-rasterization.html</div>
<div class="line">// http://blog.hvidtfeldts.net/index.php/2014/01/combining-ray-tracing-and-polygons/</div>
<div class="line"> </div>
<div class="line">    vec4 pClipSpace =  MVEPMat * vec4(pos, 1.0);</div>
<div class="line">    vec3 pNdc = vec3(pClipSpace.x / pClipSpace.w, pClipSpace.y / pClipSpace.w, pClipSpace.z / pClipSpace.w);</div>
<div class="line">    float ndcDepth = pNdc.z;</div>
<div class="line">    </div>
<div class="line">    float d = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0; </div>
<div class="line">    gl_FragDepth = d;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The model view eye projection matrix is passed in as a uniform through the <code>StudioTools::RaymarchQuadSetup()</code> function. The vectors <code>nearPos</code> and <code>farPos</code> are passed in from the vertex shader. There are two output specified. The output at <code>location = 0</code>, <code>fragColour</code>, sends the colour of the fragment to the default framebuffer which is then drawn to the screen. The output at <code>location = 1</code>, <code>dataOut</code>, writes the data contained in it to a pixel buffer object which is then read back asynchronously to the CPU. This allows data to be sent from the fragment shader to be <code>Studio::Update()</code> where it can be manipulated further. In <code>main()</code> the direction and the origin of the ray are calculated before being used in a <code>march()</code> function. This function is not shown here as there are many ways to do this. The 'hit' position is then calculated and used to determine the colour of the material. Gamma correction is applied before the colour vector is sent to the output. Although <code>fragColour</code> is also sent to <code>dataOut</code>, this does not need to be the case as any value can be output here. Finally, at the bottom of the shader, <code>pos</code> is transformed to clip space and then to normalised device coordinates. The <code>z</code> component is then used to calculate the depth <code>d</code> which is finally assigned to <code>gl_FragDepth</code>. For a discussion on how these calculations are derived see Michael Hvidtfeldt Christensen and James Sussino's blogs linked above the code section. This bloack of code allows rasterised graphics to interact with raymarched graphics and is useful when rendering the default controllers in VR. Once the shaders are initialised, graphics are drawn to the screen in <code>Studio::Draw()</code>.</p>
<div class="fragment"><div class="line">m_pStTools-&gt;DrawStart(projMat, eyeMat, viewMat, shaderProg, translateVec);</div>
<div class="line">    </div>
<div class="line">glUniform1f(m_gliSineControlValLoc, m_fSineControlVal);</div>
<div class="line">glUniform1f(m_gliPitchOutLoc, m_fPitch);</div>
<div class="line">glUniform1f(m_gliFreqOutLoc, *m_vReturnVals[1]);</div>
<div class="line"> </div>
<div class="line">m_pStTools-&gt;DrawEnd();</div>
</div><!-- fragment --><p>The function <code>DrawStart()</code> is accessed through the <code>m_pStTools</code> pointer. The projection matrix, eye matrix, view matrix, shader program handle and camera translation vector are passed to the function.Data can be passed to the shader here using <code>glUniform1f</code> or any of its variations. The uniform location handles are declared in <code>Studio::Setup()</code>. Finally, <code>DrawEnd()</code> is called which concludes the draw loop.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Mapping Overview</h1>
<p>As mentioned above, data can be mapped throughout the toolkit. Here is a brief overview of the functions used to map data.</p>
<p>From <code>Studio()</code> to Csound:</p><ul>
<li><code>StudioTools::BCsoundSend()</code> to <code>chnget</code>. From Csound to <code>Studio()</code>:</li>
<li><code>chnset</code> to <code>StudioTools::BCsoundReturn()</code>. From <code>Studio()</code> to fragment shader:</li>
<li><code>glUniform1f</code> (and related OpenGL calls <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml">https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml</a>) to <code>uniform ...</code>. From the fragment shader to <code>Studio()</code>:</li>
<li>&lsquo;out vec4 dataOut&rsquo; to <code>PBOInfo&amp; pboInfo.pboPtr</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md18"></a>
Machine Learning Walkthrough</h1>
<p>The RapidLib machine learning library is an integral part of the toolkit. Access to a neural network regression algorithm is provided through the functions <code>Studio::MLRegressionSetup()</code> and <code>Studio::MLRegressionUpdate()</code>. These functions will eventually be moved to <code>StudioTools()</code> in order to keep <code>Studio()</code> as minimal as possible. <code>Studio::MLRegressionSetup()</code> is called in <code>Studio::Setup()</code> and simply initialises various <code>bool</code>s and variables that are used in <code>Studio::MLRegressionUpdate()</code>. <code>Studio::MLRegressionUpdate()</code> is called in <code>Studio::Update()</code> and is passed the <code>machineLearning</code> struct which provides access to the machine learning controls. It is also passed the <code>pboInfo</code> struct which provides access to data returned from the fragment shader. Finally, it is passed <code>std::vector&lt;MLAudioParameter&gt; paramVec</code> which provdes access to discrete parameters that are to be processed by the neural network. <code>Studio::MLRegressionUpdate()</code> is divided into several blocks of functionality. </p><pre class="fragment">- Randomisation of parameters.
- Recording of training examples.
- Neural network training.
- Running and halting of trained regression model.
- Save trained model.
- Load saved model.
</pre><p>The interactive machine learning (IML) workflow is as follows: </p><pre class="fragment">- Choose the input and output parameters for the neural network. 
- Create input/output examples to train the neural network. The approach here is to randomise the parameters. There are many other approaches possible.
- Record the training examples to create a training set.
- Train the neural network.
- Run the model.
- Save the model.
- Load a previously saved model next time.
</pre><p>Keyboard controls for <code>dev</code> mode: </p><pre class="fragment">- Randomise parameters -&gt; space bar.
- Record training examples -&gt; r.
- Train neural network -&gt; t.
- Run trained model -&gt; g.
- Halt model -&gt; h.
- Save model -&gt; k.
- Load model -&gt; l.
</pre><p>When using a VR system the controls can be mapped to the controller buttons using the SteamVR runtime interface. The machine learning functionality is discussed further below as it relates specifically to the 'Cyclical Mapping Example'.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Example Walkthroughs</h1>
<p>This section describes the construction and execution of the examples. All of the examples are found in <em>ImmersiveAV/examples/</em>.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Audio Reactive</h2>
<p>This example demonstrates audio reactive mapping. The frequency is mapped from the audio engine to the visual structure.</p>
<p><em><b>Link to video of example on YouTube</b></em></p>
<p>The file <em>audioReactive_example.csd</em> generates the audio tone. Below is the code for the <em>Example Instrument</em>.</p>
<div class="fragment"><div class="line">**************************************************</div>
<div class="line">instr 1 ; Example Instrument</div>
<div class="line">**************************************************</div>
<div class="line"> </div>
<div class="line">kFreq   linseg  400, 2.0, 500, 2.0, 450, 4.0, 950, 5.0, 200</div>
<div class="line"> </div>
<div class="line">        chnset  kFreq, &quot;freqOut&quot;</div>
<div class="line"> </div>
<div class="line">aSig    oscil   0.7, kFreq</div>
<div class="line">gaOut = aSig</div>
<div class="line"> </div>
<div class="line">endin</div>
</div><!-- fragment --><p>Here <code>chnset</code> is used to send the value <code>kFreq</code> to the <code>Studio()</code> class using the channel <code>"freqOut"</code>. The channel <code>"freqOut"</code> is declared in <code>Studio::Setup()</code>.</p>
<div class="fragment"><div class="line">//setup returns from Csound</div>
<div class="line">std::vector&lt;const char*&gt; returnNames;</div>
<div class="line">returnNames.push_back(&quot;freqOut&quot;);</div>
<div class="line"> </div>
<div class="line">m_returnVals.push_back(m_pFreqOut);</div>
<div class="line"> </div>
<div class="line">m_pStTools-&gt;BCsoundReturn(csSession, returnNames, m_vReturnVals);</div>
</div><!-- fragment --><p>Here the string <code>"freqOut"</code> is pushed back into the vector <code>returnNames</code>. The Csound pointer <code>m_pFreqOut</code> points to the value returned from Csound. This is pushed back onto a member vector <code>returnVals</code>. These vectors are then used as arguments to the function <code>BCsoundReturn()</code> which sets up the channel.</p>
<p>The frequency value is then sent to the frag shader using <code>glUniform1f()</code> which is called in <code>Studio::Draw()</code>.</p>
<div class="fragment"><div class="line">m_pStTools-&gt;DrawStart(projMat, eyeMat, viewMat, shaderProg, translateVec);</div>
<div class="line">glUniform1f(m_gliFreqOutLoc, *m_vReturnVals[1]);</div>
<div class="line">m_pStTools-&gt;DrawEnd();</div>
</div><!-- fragment --><p>The value is sent to the shader by dereferencing the specific element in the vector <code>m_vReturnVals</code>. For the purposes of this walkthrough it is element 1 but in real use it depends in which order you push back elements in <code>Studio::Setup()</code>. The location of the uniform is given by the handle <code>m_gliFreqOutLoc</code>. This is declared in <code>Studio::Setup()</code>.</p>
<div class="fragment"><div class="line">//shader uniforms</div>
<div class="line">m_gliFreqOutLoc = glGetUniformLocation(shaderProg, &quot;freqOut&quot;);</div>
</div><!-- fragment --><p>In the frag shader, the uniform <code>freqOut</code> is declared at the top. The value is then used to manupulate the size of the sphere in the distance estimator function.</p>
<div class="fragment"><div class="line">float DE(vec3 p)</div>
<div class="line">{</div>
<div class="line">    float rad = 1.0 * (1.0 / (freqOut * 0.01));</div>
<div class="line">    float sphereDist = sphereSDF(p, rad);</div>
<div class="line">    return sphereDist;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here there is an inverse relationship between the value of <code>freqOut</code> and the radius of the sphere <code>rad</code>. Higher frequency values make the sphere smaller, lower frequency values make the sphere larger.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Simultaneous Data Mapping</h1>
<p>This example utilises the <code>Studio()</code> class to generate a stream of data. This data is then sent to the audio engine and fragment shader to simultaneously affect the audio and visuals.</p>
<p><em><b>Link to video of example on YouTube</b></em></p>
<p>The data signal is initially generated in <code>Studio::Update()</code>.</p>
<div class="fragment"><div class="line">//example control signal - sine function</div>
<div class="line">//sent to shader and csound</div>
<div class="line">m_fSineControlVal = sin(glfwGetTime() * 0.33f);</div>
<div class="line">*m_vSendVals[0] = (MYFLT)m_fSineControlVal;</div>
</div><!-- fragment --><p>The sine control value is generated using <code>sin()</code>. Then it is cast to type <code>MYFLT</code> and assigned to element 0 of the vector <code>m_vSendVals</code>. This element was assigned to the sine control signal in <code>Studio::Setup()</code>.</p>
<div class="fragment"><div class="line">//setup sends to csound</div>
<div class="line">std::vector&lt;const char*&gt; sendNames;</div>
<div class="line">sendNames.push_back(&quot;sineControlVal&quot;);</div>
<div class="line">m_vSendVals.push_back(m_cspSineControlVal);</div>
<div class="line">m_pStTools-&gt;BCsoundSend(csSession, sendNames, m_vSendVals);</div>
</div><!-- fragment --><p>Here element 0 of <code>sendNames</code> is assigned to <code>"sineControlVal"</code>. The next line then assignes the Csound pointer <code>m_cspSineControlVal</code> to element 0 of <code>m_vSendVals</code>. The elements in these two vectors need to be aligned or else the values will get paired with incorrectly names channels when they are received by Csound. Both vectors are then used as arguments for the function <code>BCsoundSend()</code>. This sets up the send channel with the instance of Csound. The file <em>simultaneousDataMapping.csd</em> receives the data stream through the channel named <code>"sineControlVal"</code>.</p>
<div class="fragment"><div class="line">********************************************************</div>
<div class="line">instr 1 ; Example Instrument</div>
<div class="line">********************************************************</div>
<div class="line">kSineControlVal     chnget      &quot;sineControlVal&quot;</div>
<div class="line"> </div>
<div class="line">aSig        oscil   0.7, 400.0 * (1 / kSineControlVal)</div>
<div class="line">gaOut       aSig</div>
<div class="line"> </div>
<div class="line">endin</div>
</div><!-- fragment --><p>Here the opcode <code>chnget</code> is used to assigne the control data to <code>kSineControlVal</code>. This is then used to alter the frequency value. The sine data is also sent from <code>Studio::Draw()</code> to the frag shader.</p>
<div class="fragment"><div class="line">m_pStTools-&gt;DrawStart(projMat, eyeMat, viewMat, shaderProg, translateVec);</div>
<div class="line">glUniform1f(m_gliSineControlValLoc, m_fSineControlVal);</div>
<div class="line">m_pStTools-&gt;DrawEnd();</div>
</div><!-- fragment --><p>Here the float value is sent as a uniform using the <code>m_gliSineControlValLoc</code> handle that was set up in <code>Studio::Setup()</code>.</p>
<div class="fragment"><div class="line">//shader uniforms</div>
<div class="line">m_gliSineControlValLoc = glGetUniformLocation(shaderProg, &quot;sineControlVal&quot;);</div>
</div><!-- fragment --><p>The name of the shader is specified as <code>"sineControlVal"</code> within the shader.</p>
<div class="fragment"><div class="line">uniform float sineControlVal;</div>
<div class="line"> </div>
<div class="line">float DE(vec3 p)</div>
<div class="line">{</div>
<div class="line">    p.y *= 1.0 * sineControlVal;</div>
<div class="line">    float rad = 2.0;</div>
<div class="line">    float sphereDist = sphereSDF(p, rad);</div>
<div class="line">    return sphereDist;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here <code>sineControlVal</code> is used to increase and decrease <code>p.y</code> which is the height of the sphere. The point <code>p</code> is then send to <code>sphereSDF()</code> which estimates the distance to the spere.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Cyclical Mapping Example</h1>
<p>This example demonstrates a method of mapping data in a cyclical way between the audio and visuals using a neural network based regression algorithm. Pixel data from the fragment shader is used as input into the neural network. Ocsillator frequency values are then output and sent to the audio engine. An FFT analysis is used to determine the pitch of the resulting audio signal. This pitch value is sent to the shader to inversely affect the size of the sphere. The pixel data changes accordingly and is sent back to the neural network beginning the cycle again.</p>
<p><em><b>link to video of example on YouTube</b></em></p>
<p>The frequency of the audio signal is set up to be randomised. The random parameter is defined in <code>Studio::Update()</code> using the <code>MLAudioParameter</code> struct.</p>
<div class="fragment"><div class="line">//run machine learning</div>
<div class="line">MLAudioParameter paramData;</div>
<div class="line">paramData.distributionLow = 400.0f;</div>
<div class="line">paramData.distributionHigh = 1000.0f;</div>
<div class="line">paramData.sendVecPosition = 1;</div>
<div class="line">std::vector&lt;MLAudioParameter&gt; paramVec;</div>
<div class="line">paramVec.push_back(paramData);</div>
<div class="line">MLRegressionUpdate(machineLearning, pboInfo, paramVec);</div>
</div><!-- fragment --><p>The value will always be between <code>400.0f</code> and <code>1000.0f</code>. It is assigned to element number 1 in the vector <code>m_vSendVals</code>. This is declared in <code>Studio::Setup()</code> where the channel is named <code>"randomVal"</code>. This allows Csound to receive the random value on this channel. The object <code>paramData</code> is then pushed back onto the vector <code>paramVec</code> and passed to <code>Studio::MLRegressionUpdate()</code>. When the randomise button is pressed (space bar in dev mode), this random value is calculated and sent to Csound.</p>
<div class="fragment"><div class="line">for(int i = 0; i &lt; params.size(); i++)</div>
<div class="line">{</div>
<div class="line">    std::uniform_real_distribution&lt;float&gt; distribution(params[i].distributionLow, params[i].distributionHigh);</div>
<div class="line">    std::default_random_engine generator(rd());</div>
<div class="line">    float val = distribution(generator);</div>
<div class="line">    *m_vSendVals[params[i].sendVecPosition] = (MYFLT)val;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This <code>for</code> loop iterates through the vector <code>std::vector&lt;MLAudioParameter&gt; params</code>. For each parameter it calculates the <code>float val</code> within the given range. It then casts the value to <code>MYFLT</code> and assigns it to the relevant position in the vector <code>m_vSendVals</code>. This assigns the value to the previously declared channel which is received in the file <code>cyclicalMapping_example.csd</code>.</p>
<div class="fragment"><div class="line">;**************************************************************************************</div>
<div class="line">instr 1 ; Example Instrument</div>
<div class="line">;**************************************************************************************</div>
<div class="line">kRandomParam chnget &quot;randomVal&quot;</div>
<div class="line"> </div>
<div class="line">aSig oscil .7, kRandomParam </div>
<div class="line"> </div>
<div class="line">gaOut = aSig</div>
<div class="line"> </div>
<div class="line">iFftSize = 1024</div>
<div class="line">iOverlap = iFftSize / 4 </div>
<div class="line">iWinSize = iFftSize </div>
<div class="line">iWinType = 1</div>
<div class="line"> </div>
<div class="line">fSig    pvsanal aSig, iFftSize, iOverlap, iWinSize, iWinType</div>
<div class="line"> </div>
<div class="line">kThresh = 0.1</div>
<div class="line">kPitch, kAmp    pvspitch fSig, kThresh</div>
<div class="line"> </div>
<div class="line">    chnset  kPitch, &quot;pitchOut&quot;</div>
<div class="line"> </div>
<div class="line">endin</div>
</div><!-- fragment --><p>Here the value recieved on the <code>"randomVal"</code> channel is stored in <code>kRandomParam</code>. This is then used as the frequency value for <code>oscil</code>. The signal <code>aSig</code> is sent to the output. It is also passed to <code>pvsanal</code> where an FFT analysis converts the time domain signal to the frequency domain. This signal, <code>fSig</code> is then passed to <code>pvspitch</code> which calculates its pitch and amplitude. The pitch value, <code>kPitch</code> is then sent back to <code>Studio()</code> on the channel <code>"pitchOut"</code>, which was defined in <code>Studio::Setup()</code>. This data stream is then processed in <code>Studio::Update()</code>.</p>
<div class="fragment"><div class="line">// spectral pitch data processing</div>
<div class="line">m_fCurrentFrame = glfwGetTime();</div>
<div class="line">m_fDeltaTime = m_fCurrentFrame - m_fLastFrame;  </div>
<div class="line">m_fDeltaTime *= 1000.0f;</div>
<div class="line">if(*m_vReturnVals[0] &gt; 0) m_fTargetVal = *m_vReturnVals[0]; </div>
<div class="line">if(m_fTargetVal &gt; m_fCurrentVal)</div>
<div class="line">{</div>
<div class="line">    m_fCurrentVal += m_fDeltaTime;</div>
<div class="line">} else if(m_fTargetVal &lt;= m_fCurrentVal)</div>
<div class="line">{</div>
<div class="line">    m_fCurrentVal -= m_fDeltaTime;</div>
<div class="line">} else if(m_fTargetVal == m_fCurrentVal)</div>
<div class="line">{</div>
<div class="line">    m_fCurrentVal = m_fTargetVal;</div>
<div class="line">}</div>
<div class="line">if(m_fCurrentVal &lt; 0.0f) m_fCurrentVal = 0.0f;</div>
<div class="line">m_fPitch = m_fCurrentVal;</div>
</div><!-- fragment --><p>Here element 0 of <code>m_vReturnVals[]</code> is dereferenced and assigned to the <code>float m_fTargetVal</code>. The values in the data stream can vary quickly. To create smooth visual movement, it is necessary to move gradually from one value to the next rather than instantly jump between values. The <code>m_fTargetVal</code> value is compared to the value represented by <code>m_fCurrentVal</code>. If it is larger, <code>m_fCurrentVal</code> is increased gradually by <code>m_fDeltaTime</code> increments each frame. These increments are calculated by taking the timestamp of the current frame and subtracting it from the timestamp of the next frame. This gives a constant value from frame to frame. If <code>m_fTargetVal</code> is less than <code>m_fCurrentVal</code>, it is decreased by <code>m_fDeltaTime</code> increments each frame. If the two values are equal, then the value of <code>m_fTargetVal</code> is assigned to <code>m_fCurrentVal</code>. Finally, <code>m_fCurrentVal</code> is checked to make sure it is greater than zero before being assigned to <code>m_fPitch</code>. This <code>float</code> is passed to the shader through the uniform <code>"pitchOut"</code>.</p>
<div class="fragment"><div class="line">m_pStTools-&gt;DrawStart(projMat, eyeMat, viewMat, shaderProg, translateVec);</div>
<div class="line">glUniform1f(m_gliPitchOutLoc, m_fPitch);</div>
<div class="line">m_pStTools-&gt;DrawEnd();</div>
</div><!-- fragment --><p>In a similar way to the audio reactive example above, the uniform value is used to affect the size of the sphere.</p>
<div class="fragment"><div class="line">float DE(vec3 p)</div>
<div class="line">{</div>
<div class="line">    p.y -= 1.0;</div>
<div class="line">    float rad = 1.0 * (1.0 / (pitchOut * 0.01));</div>
<div class="line">    float sphereDist = sphereSDF(p, rad);</div>
<div class="line">    return sphereDist;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The value <code>pitchOut</code> is inversely related to the radius of the sphere which means the higher the pitch value the smaller the sphere. Conversely, the lower the pitch value, the larger the sphere. The fragment shader sends pixel colour data back to <code>Studio()</code> asynchronously using a pixel buffer object (PBO).</p>
<div class="fragment"><div class="line">layout(location = 0) out vec4 fragColour; </div>
<div class="line">layout(location = 1) out vec4 dataOut;</div>
<div class="line"> </div>
<div class="line">// Output to screen</div>
<div class="line">fragColour = vec4(colour,1.0);</div>
<div class="line"> </div>
<div class="line">// Output to PBO</div>
<div class="line">dataOut = fragColour;</div>
</div><!-- fragment --><p>There are two outputs of type <code>vec4</code> specified in the fragment shader. The vector <code>fragColour</code> at <code>location = 0</code> is the usual output of the fragment colour to the screen. The other output, <code>dataOut</code>, writes the data to a PBO. In this example, the colour vector of the fragment is passed to it. The data in the PBO is then read back into memory on the CPU and is accessible from <code>Studio::Update()</code> through the struct <code>PBOInfo</code>. This struct is then passed to <code>MLRegressionUpdate()</code> where the data can be used as input to the neural network.</p>
<div class="fragment"><div class="line">if(machineLearning.bRecord)</div>
<div class="line">{</div>
<div class="line">    //shader values provide input to neural network</div>
<div class="line">    for(int i = 0; i &lt; pboInfo.pboSize; i+=pboInfo.pboSize * 0.01)</div>
<div class="line">    {</div>
<div class="line">        inputData.push_back((double)pboInfo.pboPtr[i]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    //neural network outputs to audio engine </div>
<div class="line">    for(int i = 0; i &lt; params.size(); i++)</div>
<div class="line">    {</div>
<div class="line">        outputData.push_back((double)*m_vSendVals[params[i].sendVecPosition]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    trainingData.input = inputData;</div>
<div class="line">    trainingData.output = outputData;</div>
<div class="line">    trainingSet.push_back(trainingData);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; &quot;Recording Data&quot; &lt;&lt; std::endl;</div>
<div class="line">    inputData.clear();</div>
<div class="line">    outputData.clear();</div>
<div class="line">}</div>
<div class="line">machineLearning.bRecord = false;</div>
</div><!-- fragment --><p>When a desired sound and visual pairing is found, they can then be recorded (<code>R</code> in <code>dev</code> mode) to create a training example. In this example you would be pairing the position of the sphere in the visual field and the perceived pitch of the tone. This process can be repeated as many times as needed to create a <em>training set</em>. When the record button is pressed, a <code>for loop</code> steps through the buffer in <code>pboInfo.pboSize * 0.01</code> increments. This is to ensure the number of input values is reduced to cut down on training time. The values are pushed back onto the vector <code>inputData</code>. The format of the shader data is <code>unsigned char</code>. Therefore each value will be between 0 and 255. In a real world situation these values should be normalised before they are used as training data. The next <code>for loop</code> iterates through the <code>params</code> vector and retrieves the <code>sendVecPosition</code> of each one. Here there is only one parameter. This is then used as an index to the <code>m_vSendVals</code> vector. The value at this position in the vector is pushed back into the <code>outputData</code> vector. The input and output vectors are then added to the <code>trainingData</code> struct and pushed back into the <code>trainingSet</code> vector. Once the training set is complete, the neural network is trained (<code>T</code> in <code>dev</code> mode). Once training is complete, the model can be activated by pressing the run button (<code>G</code> in <code>dev</code> mode) or deactivated by pressing the halt button (<code>H</code> in <code>dev</code> mode). The model can then be saved (<code>K</code> in <code>dev</code> mode) and loaded (<code>L</code> in <code>dev</code> mode) for easy future access. When not in <code>dev</code> mode the controls can be assigned to the controller buttons through the desktop interface.</p>
<p>To summarize, when the neural network is trained and running, it is processing pixel colour values and mapping them to a specific frequency value. The audio is then analysed using an FFT and a pitch value is calculated. This pitch value is mapped to the size of the sphere. The changes in pixel values are then fed back into the neural network to produce another frequency value. This results in a continuous mapping of data between the audio and the visuals. In this example it results in a glitchy type audio effect and rapidly moving visuals that are tightly synchronised. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19
</small></address>
</body>
</html>
